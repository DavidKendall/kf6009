---
layout: default
title: Pluscal, TLA+, TLC - Modelling mutex protocols and checking liveness properties
<!--license: https://github.com/DavidKendall/blinky/blob/master/LICENSE-->
---
* TOC
{: toc}

## Introduction

Aims

* Make progress with Pluscal, TLA+ and TLC in modelling and analysing some 
  simple concurrent systems
* Use Pluscal, TLA+ and TLC to model and analyse simple mutex protocols with 
  respect to safety and liveness properties

## Checking Safety and Liveness Properties of Mutex Using Pluscal, TLA+ and TLC

Use Pluscal/TLA+ to model and verify the algorithms below for maintaining
mutually exclusive access to a critical section in a 2 process system. <br/>
**Note** You *must* use the [Pluscal P-Syntax]({{site.baseurl}}{{site.raurl}}/p-manual.pdf)
for all Pluscal work in this module.

You should check for the following properties:

1. Mutual exclusion is preserved. i.e. at most one process is in its critical
   section at any one time.

1. Deadlock is avoided. You can assume that no process will remain in its
   critical section forever but not that a process will ever try to enter its
   critical section.

1. Both processes make progress, i.e. any process that tries to enter its
   critical section eventually will do so.

Verification of these properties can be carried out with TLC by using the
following techniques:

1. *Invariants* for checking for preservation of mutual exclusion. You will
   need to think of a property, which you can include in your model, which if
   invariantly TRUE guarantees that mutual exclusion is preserved. Use TLC to
   check that your property is an invariant of your model.

1. *Invariants* for checking for progress. You will need to think of a
   property, which you can include in your model, which if invariantly TRUE
   guarantees that processes always make progress eventually. In this case,
   that means that any process that tries to enter its critical section will
   eventually do so. Use TLC to check that your property is an invariant of
   your model.

1. *Model Overview* in the model overview, select the `Deadlock` checkbox to
   ensure that TLC checks for an absence of deadlock

In each case, if TLC reports an error, use the `Error Trace` window to work out
why the error occurred. Explain the reason in plain English.

The algorithms are illustrated below using UML activity diagrams.

### Algorithm 3
There are two processes. Each process executes the same algorithm, shown below. 
`entry` is a shared variable, used to control entry to the critical section.
If `entry` is "allowed", a process can proceed to enter its critical section,
otherwise it must wait. As soon as the process has permission to enter its
critical section, it sets `entry` to "forbidden" to lock out the other process.
When the process finishes its critical section, it sets entry to "allowed"
again to allow the other process to proceed. 

![Algorithm 3]({{site.baseurl}}/assets/images/mutex03.png)

1. Create a TLA+ module called `Mutex03`. 

1. Enter a Pluscal algorithm to model the behaviour of the processes.

1. Use the Pluscal translator to translate the Pluscal algorithm into TLA+.
   You will need to think about how to express *fairness* this time.
   Refer to the [Pluscal manual]({{site.baserul}}{{site.raurl}}/p-manual.pdf). 
   Read section 4.5, the introduction to 5.10 and then
   5.10.1 and 5.10.2 to help with this.

1. Define a type invariant, `TypeOk`, in TLA+, that specifies what values the 
   variables in the model are allowed to take.

1. Define a predicate, `Mutex`, in TLA+, that should be invariantly TRUE, if the
   algorithm preserves mutual exclusion.

1. Define a predicate, `Progress` that says whenever any progress tries to
   enter its critical section, it will eventually be allowed to do so.

1. Create a new model, `Model_1` using the `TLC Model Checker`. In the 
   `Model Overview`, set the `behavior spec` to 
   `Initial predicate and next-state relation`.

1. Add the invariants that you defined earlier to the `Model Overview`. 

1. Make sure that the `Deadlock` checkbox is selected.

1. Add the `Progress` property to the `Properties` box in the `Model Overview`.

1. Run the TLC model checker and interpret the error trace.

1. **Note** You should not try to fix the error at this stage. Once you have
   completed the exercise and understood why the error arises, move on to 
   algorithm 4.

### Algorithm 4
There are two processes. Each process executes a similar algorithm, shown
below. There is a shared, 2-element array, `req_cs`. If `req_cs[1]` is
TRUE, then process 1 requires use of the critical section. Similarly,
for `req_cs[2]` and process 2. Before entering the critical section,
a process sets its own `req_cs` element to TRUE. It then checks the
`req_cs` element of the other process. If FALSE, the process can proceed,
otherwise it must wait. When the process finishes its critical section,
it sets its own `req_cs` element to FALSE to allow the other process to 
proceed.

![Algorithm 4]({{site.baseurl}}/assets/images/mutex04.png)

1. Create a TLA+ module called `Mutex04`. 

1. Enter a Pluscal algorithm to model the behaviour of the processes,
   considering fairness.

1. Use the Pluscal translator to translate the Pluscal algorithm into TLA+.

1. Define a type invariant, `TypeOk`, in TLA+, that specifies what values the 
   variables in the model are allowed to take.

1. Define a predicate, `Mutex`, in TLA+, that should be invariantly TRUE, if the
   algorithm preserves mutual exclusion.

1. Define a predicate, `Progress` that says whenever any progress tries to
   enter its critical section, it will eventually be allowed to do so.

1. Create a new model, `Model_1` using the `TLC Model Checker`. In the 
   `Model Overview`, set the `behavior spec` to 
   `Initial predicate and next-state relation`.

1. Add the invariants that you defined earlier to the `Model Overview`. 

1. Add the `Progress` property to the `Properties` box in the `Model Overview`.

1. Make sure that the `Deadlock` checkbox is selected.

1. Run the TLC model checker and interpret the error trace.

1. **Note** You should not try to fix the error at this stage. Once you have
   completed the exercise and understood why the error arises, move on to
   algorithm 5.

### Algorithm 5
There are two processes. Each process executes a similar algorithm, shown
below. There is a shared, 2-element array, `req_cs`. If `req_cs[1]` is
TRUE, then process 1 requires use of the critical section. Similarly,
for `req_cs[2]` and process 2. Before entering the critical section,
a process sets its own `req_cs` element to TRUE. It then checks the
`req_cs` element of the other process. If FALSE, the process can proceed,
otherwise it must wait. When the process finishes its critical section,
it sets its own `req_cs` element to FALSE to allow the other process to 
proceed.

![Algorithm 5]({{site.baseurl}}/assets/images/mutex05.png)

1. Create a TLA+ module called `Mutex02`. 

1. Enter a Pluscal algorithm to model the behaviour of the processes,
   considering fairness.

1. Use the Pluscal translator to translate the Pluscal algorithm into TLA+.

1. Define a type invariant, `TypeOk`, in TLA+, that specifies what values the 
   variables in the model are allowed to take.

1. Define a predicate, `Mutex`, in TLA+, that should be invariantly TRUE, if the
   algorithm preserves mutual exclusion.

1. Define a predicate, `Progress` that says whenever any progress tries to
   enter its critical section, it will eventually be allowed to do so.

1. Create a new model, `Model_1` using the `TLC Model Checker`. In the 
   `Model Overview`, set the `behavior spec` to 
   `Initial predicate and next-state relation`.

1. Add the invariants that you defined earlier to the `Model Overview`. 

1. Add the `Progress` property to the `Properties` box in the `Model Overview`.

1. Make sure that the `Deadlock` checkbox is selected.

1. Run the TLC model checker and interpret the error trace, or make sure that
   you understand why there is no error trace.


## Homework

1. Make sure that you have completed all exercises to date.




